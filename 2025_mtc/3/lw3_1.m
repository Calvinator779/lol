% lw3_1.m
run('../1/lw1_params.m'); % Завантаження A, B, G з Лаб 1

w0_reg = 30; % з Лаб 2
p_reg = roots([1 2.6*w0_reg 3.4*w0_reg^2 2.6*w0_reg^3 w0_reg^4]);
H = acker(A, B, p_reg);

% 1. Матриця вимірювань (Варіант 12: вимірюється x2)
C = [0, 1, 0, 0]; 

x0 = [1; 0; 0; 0];
x00= [0; 0; 0; 0];

t_sim = '1.5';

Qo = obsv(A, C);
rank_Qo = rank(Qo);

fprintf('Ранг матриці спостережуваності: %d\n', rank_Qo);
if rank_Qo == size(A, 1)
    disp('Система повністю спостережувана.');
else
    error('Система неспостережувана!');
end

w0c = 40; % Власна частота спостережувача (Вар. 12)

% Поліном мінімуму сер. кв. помилки (p^4 + w*p^3 + 3w^2*p^2 + 2w^3*p + w^4)
coeffs_obs = [1, 1*w0c, 3*w0c^2, 2*w0c^3, 1*w0c^4];
poles_obs = roots(coeffs_obs);

% Розрахунок K (дуальна задача до acker)
% K обчислюється як транспонований результат acker для транспонованої системи
% бере вашу матрицю A, матрицю C і бажані полюси, складає характеристичне 
% рівняння і знаходить такі k_1, k_2, k_3, k_4, щоб рівняння зійшлося.
K = acker(A', C', poles_obs)';

disp('Розрахована матриця K:');
disp(K);

% Перевірка полюсів спостережувача
disp('Полюси (A - KC):');
disp(eig(A - K*C));

% Ранг матриці спостережуваності: 4
% Система повністю спостережувана.
% Розрахована матриця K:
%    1.0e+08 *

%     7.4664
%     0.0000
%     0.0000
%     0.0001

% Полюси (A - KC):
%   -4.1951 +62.0997i
%   -4.1951 -62.0997i
%  -15.8049 +20.2738i
%  -15.8049 -20.2738i
